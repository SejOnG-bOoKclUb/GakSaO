## 4장 역할, 책임, 협력
+ 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.
+ 책임을 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다.

### 책임
+ 객체가 알아야 하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장
+ 하는 것
  + 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  + 다른 객체의 행동을 시작시키는 것
  + 다른 객체의 활동을 제어하고 조절하는 것
+ 아는 것
  + 개인적인 정보에 관해 아는 것
  + 관련된 객체에 관해 아는 것
  + 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
+ 명확한 책임이 애플리케이션의 미래를 결정 짓는다
+ 공용 인터페이스로를 구성

### 역할
+ 책임의 집합이 의미하는 것
+ 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소
+ 역할은 협력 내에서 다른 객체로 대체될 수 있음을 나타내는 일종의 표식
+ 동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 떄문에 동일한 책임을 수행할 수 있다
+ 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침 함
+ 협력의 추상화 가능

# 객체지향의 핵심
## 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지 결정하는 것
### 객체설계
+ 첫번째 깔끔한 협력 설계
  + 요청과 응답
+ 이러한 흐름이 책임이 됨
+ 책임은 외부에 제공하게 될 행동이 됨

### 객체지향 설계 기법
+ #### 책임 주도 설계
  + 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를
  + 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식
    + 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    + 시스템 책임을 더 작은 책임으로 분할한다.
    + 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    + 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    + 해당 객체 또는 역할에게 책임을 할당함으로서 두 객체가 협력하게 한다.
+ #### 디자인 패턴
  + 책임 주도 설계의 결과를 표현
+ #### 테스트 주도 개발
  + 테스트를 했을 때 적절한 답이 나오도록 구현

## 5장 책임과 메시지
+ 의도는 "메시징"이다.
+ 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려있다.
+ 객체가 얼마나 자율적인지에 따라 애플리케이션의 품질을 결정
  + 객체에게 할당되는 책임이 자율적이어야 함
  + (ex. 증언의 방식이나 필요한 자료는 자유롭게 선택)
  + 책임의 수준이 자율적이어야 함
  + 그렇다고 너무 추상적이면 안됨
  + 어떻게가 아니라 무엇을 해야 한다고 책임을 부여해야 함
+ 메시지를 처리하기 위해 선택하는 증언 방법이 메서드

### 다형성은 대체 가능성을 의미
+ 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있음
+ 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들 수 있기 때문

#### 객체지향 시스템은 협력하는 객체들의 연결망이다.
#### 시스템은 객체를 생성하고 상호 간에 메시지를 송신할 수 있게 이들을 끼워 맞춤으로써 구축된다.
#### 시스템의 행위는 객체들의 조합으로 창발되는 속성이다.
#### 이것은 객체의 조합을 변경함으로써 시스템의 행위를 변경할 수 있게 한다.
#### 객체의 조합을 관리하기 위해 작성하는 코드는 객체 연결망이 어떻게 행동할 것인지에 대한 선언적인 정의다.
#### 객체가 어떻게 할 것인지보다는 무엇을 할 것인지에 초점을 맞추기 때문에 시스템의 행위를 변경하기 쉽다.

## 클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위르 식별하는 것이 먼저

+ 메시지가 객체를 선택하게 하는 것

### 인터페이스
+ 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치
+ 메시지를 따르면 최소 인터페이스를 얻을 수 있다
+ 객체 내부와 외부를 분리하는 것은 중요하다.
+ 객체 외부를 공용 인터페이스라고 한다.
+ 내부는 구현이다
+ 메서드, 상태는 구현에 해당한다
+ #### 훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미
+ 인터페이스와 구현의 분리원칙
+ == 캡슐화
+ 객체지향이 유연하고 재사용이 가능하다고 알려진 이유는 객체의 내부와 외부를 명확히 구분하기 때문
+ 




